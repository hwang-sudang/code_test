# 곱하기 또는 더하기, p.312
# 모든 연산은 왼쪽에서 부터 순서대로 + x 상관없이

# 각 자리가 숫자(0~9)로 이루어진 문자열 S 주어짐
S = list(map(int, input().strip())) #빈칸이 없어서 strip 사용
max_number = 0

for i in range(len(S)):
    if max_number == 0 or max_number == 1: # 전 숫자가 0 이면...
        max_number += S[i]
    else:
        max_number *= S[i]

max_number # 정답



#-------------------------------------------------------
'''
사유 과정.
가장 큰 숫자가 나올 수 있도록?
1. 일단 무조건 큰 숫자는 곱하기로 빼야 한다.
2. 0과 1은 더하는 게 낫다. (그 직전 숫자면..)
3. 나머지는 곱하는 게 이득

'''

#-------------------------------------------------------
# 문자열 뒤집기 
# 무조건 한 번은 뒤집어라 #스위칭인지 스위핑 알고리즘

S = list(map(int, input().strip()))
max_number = 0
max_ =[]

for i,j in zip(range(len(S)), range(1, len(S))):
    if S[i] != S[j]:
        max_.append(j)
        
answer = -(-len(max_)//2) 
answer

'''
연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것
1. 지금 원소와 뒤의 원소가 다르다면, 그 뒤의 원소의 위치를 빈 리스트에 넣는다
2. 그 다음 원소의 위치가 기록된 리스트의 길이를 확인하고, 내림을 해준다.
3. 2번의 연산결과가 답.
'''

#--------------------------------------------------------
#########################################################
# 만들 수 없는 금액 # 해결 못함.
# N = 5, 각 동전이 3, 2, 1, 1, 9원 동전.
# 가지고 있는 동전을 가지고 만들 수 없는 최솟값은 8원

N =int(input())
S = list(map(int, input().split(' ')))

S.sort()

target=1
for x in S:
    if target < x:
        print(target, x)
        break
    
    print(target, x)
    target += x
print(target)    


##########################################################
#--------------------------------------------------------
# 볼링공 고르기 p. 315

N, M= map(int, input().split(' ')) # 볼링공 갯수, 볼링공 고르는 경우
K = list(map(int, input().split(' ')))

# 두 사람은 서로 무게가 다른 다른 볼링공을 고르려고 한다.
cnt = 0
    
for i in K:
    for j in K:
        if i==j:
            pass
        else:
            cnt+=1
            
int(cnt/2)
# 근데 숫자 커지면 ... O(n^2)라서 효율성 쉣

# 대신 O(2n)--------------------------------------------

'''
1. 무게마다 볼링공이 몇 개 있는 지 카운트
2. A가 특정 무게의 볼링공을 선택했을 때, 이어서 B가 볼링공을 선택하는 경우.
3. 그러나, 순서가 다르고 원소가 같은 경우는 동일한 경우로 쳐줘야 하므로 무조건 
A보단 가벼운 걸 선택하도록 해야 한다.

'''

# 입력
N, M= map(int, input().split(' ')) # 볼링공 갯수, 볼링공 고르는 경우
K = list(map(int, input().split(' ')))

# 각 무게에 해당하는 볼링공의 개수 카운트
temp = [0]*10  # 최대 무게 10 / 나중엔 그냥 dict로 해결해도 될 듯.

for i in K:
    temp[i] += 1

# A가 고르고, B는 무조건 작은 걸 골라라!
cnt = 0
for i in temp:  # i는 먼저 고르는 사람의 공 무게
    N -= i
    cnt += N * i

print(cnt)


#---------------------------------------------------------







    
    
    
    
    