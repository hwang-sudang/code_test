# 무지의 먹방교실??

# 마지막 문제 무지의 먹방라이브 p.316

Food_times = list(map(int, input().split(' ')))
k = int(input())

cnt = sum(Food_times) # 6
i = 0

for _ in range(k): # 5초
    if i > len(Food_times)-1 :
        i -= len(Food_times)
    
    else: 
        if Food_times[i] == 0 :
            i+=1
            pass
        else: 
            Food_times[i] -= 1
            cnt -= 1
            i+=1

print(i) # 파이썬 인덱스 구조에 따라서. 다시 그 전 음식부터 먹으면 됩니다.   
 




# 모범 답안 : 우선순위 큐를 이용해서 ----------------------------------
'''
513쪽

아이디어 : 탐욕적 방법 -> 먼저 가장 시간이 조금 걸리는 음식별로 정리해서 해결

{0} 모든 음식을 우선순위 큐, 최소 힙에 삽입한다. 
또한 마지막에는 K초 후에 먹어야 할 음식의 번호를 출력해야 하므로, 우선순위 큐에 삽입할 때
(음식 시간, 음식 번호)의 튜플 형태로 삽입한다.

{1} 가장 적게 걸리는 음식을 제외한다. [8,6,4]가 있다면, 3번 음식이다.
다만 음식이 3개 남아 있으므로 
3(남은 음식의 개수)*4(3번 음식을 먹는데 걸리는 총 시간)=12를 빼야한다. (돌아가면서 먹으니까)
=> 3번 음식을 다 먹으려면 12초가 걸린다.

{2} 1을 통해 전체 남은 시간은 3초 뿐. 남은 음식은 2개
이번 단계에서는 두 번째로 다 먹지 못한 음식인 2번을 빼야한다. 
그러나 2*6초(2번음식 6초걸림) --> 2번음식은 제외될 수 없다. 패쓰

{3} 그렇다면 남은 1,2 번 음식 중에 '다음으로 먹어야 할 음식의 번호를 찾아 출력' -> 단순정렬
남은 시간 3초 :
    0초 : 1번음식
    1초 : 2번음식
    2초 : 1번
    3초 : 2번음식 --> 정답


    
요약
1. 먼저 가장 금방 먹는 음식을 고르고, 총 걸리는 시간 < 방송끊기는 시간?
2. 통과되면 그 다음 음식에 대해 검증, 불통과면 단순 나열문제로 해결
 
'''




# 알고리즘

import heapq

def solution(food_times,k):
    # 전체 음식을 먹는 시간보다 K가 크거나 같다면 -1
    if sum(food_times) <= k :
        return -1  #이미 방종

    q =[] 
    for i in range(len(food_times)):
        heapq.heappush(q, (food_times[i], i+1))
        
    sum_value = 0 # 먹기 위해 사용한 시간
    previous = 0 # 직전에 다 먹은 음식 시간
    length = len(food_times) # 남은 음식 수
    
    '''## sum_value + (현재 음식 시간 - 이전 음식 시간) 을 현재 음식 개수 K와 비교 ##
    # q[0][0] : 가장 빨리 먹어치울 음식을 먹는 데 걸리는 숫자
    # previous : 직전에 다 먹어치운 음식이 있는 경우, 그 음식을 다 먹는 데 걸린 시간
    # k : 방송 중단 시간
    # sum_value : 지금까지 먹는데 쓴 시간 '''
    
    # while 이하 문 해석 -> 지금 현재 밥먹는 데 쓴 시간이 k보다 작으면 루프 돌려:
    while sum_value + ((q[0][0]-previous)*length) <= k:
        # now : 최소 힙인 q애서 젤 첫번째 () 끄내서 가져온 것 중, 시간(4초) -> heappop
        now = heapq.heappop(q)[0]
        # sum_value : 누적 시간인 듯. += 는 예로 들어 3음식 다먹고 2음식 먹을때 추가로 걸리는 시간
        sum_value += (now-previous) * length
        length -= 1 # 다 먹은 음식 제외
        previous = now # 이전 음식 시간 재설정
        
  
    
    
    # 남은 음식 중에서 몇 번째 음식인지 확인하여 출력
    result = sorted(q, key=lambda x : x[1])
    return result[(k-sum_value)%length][1]
    
    


#----------------------------------------------------


food_times = [8,6,4]
k = 15

q=[]
for i in range(len(food_times)):
    heapq.heappush(q, (food_times[i],i+1)) #q에 (,)  우선순위 큐 삽입. 
# 출력 : [(4, 3), (8, 1), (6, 2)]  꼭 교과서 보고 모양을 참고! 상 우 좌 순서로 되어 잇다.
    
print(heapq.heappop(q)[0])   
# 출력 : 4
# 그럼과 동시에, heap 구조 때문에 바로 q가 ->[(6, 2), (8, 1)] 스고이!!!




   
#--------------------------------------------------------------


